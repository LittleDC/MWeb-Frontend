<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  函数 - 
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html"></a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; </span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>dailyLife</label></li>

          
            <li><a title="holiday" href="16489947353638.html">holiday</a></li>
          
            <li><a title="practice" href="16481332591584.html">practice</a></li>
          
            <li><a title="JS每日一题" href="16471841635278.html">JS每日一题</a></li>
          
            <li><a title="🤯" href="16462320184228.html">🤯</a></li>
          
            <li><a title="notes" href="16460176233572.html">notes</a></li>
          

      
        <li class="divider"></li>
        <li><label>algorithm</label></li>

          
            <li><a title="算法小记" href="16464916020294.html">算法小记</a></li>
          

      
        <li class="divider"></li>
        <li><label>network</label></li>

          
            <li><a title="HTTPS" href="16445059759610.html">HTTPS</a></li>
          
            <li><a title="HTTP" href="16434685816689.html">HTTP</a></li>
          
            <li><a title="应用层" href="16429345213468.html">应用层</a></li>
          
            <li><a title="传输层" href="16427785444311.html">传输层</a></li>
          
            <li><a title="网络层" href="16406143899741.html">网络层</a></li>
          
            <li><a title="数据链路层" href="16393212106516.html">数据链路层</a></li>
          
            <li><a title="计算机网络" href="16376768137573.html">计算机网络</a></li>
          

      
        <li class="divider"></li>
        <li><label>JS Pro</label></li>

          
            <li><a title="⭐️期约与异步函数" href="16402238078899.html">⭐️期约与异步函数</a></li>
          
            <li><a title="函数" href="16393591389076.html">函数</a></li>
          
            <li><a title="代理与反射" href="16393584526044.html">代理与反射</a></li>
          
            <li><a title="⭐️对象,类与面对对象编程" href="16382370352660.html">⭐️对象,类与面对对象编程</a></li>
          
            <li><a title="迭代器与生成器" href="16382368417536.html">迭代器与生成器</a></li>
          
            <li><a title="集合应用类型" href="16344851791468.html">集合应用类型</a></li>
          
            <li><a title="红宝书" href="16324468661377.html">红宝书</a></li>
          

      
        <li class="divider"></li>
        <li><label>Vue</label></li>

          
            <li><a title="Principle" href="16417423637971.html">Principle</a></li>
          
            <li><a title="Webpack" href="16401645826486.html">Webpack</a></li>
          
            <li><a title="vue cli" href="16401638058072.html">vue cli</a></li>
          
            <li><a title="vue router" href="16400576847027.html">vue router</a></li>
          

      
        <li class="divider"></li>
        <li><label>electron</label></li>

          

      
        <li class="divider"></li>
        <li><label>Trick</label></li>

          
            <li><a title="笔试题" href="16512067476067.html">笔试题</a></li>
          
            <li><a title="MySQL" href="16417742815461.html">MySQL</a></li>
          
            <li><a title="eslint - vue" href="16378340644786.html">eslint - vue</a></li>
          
            <li><a title="我也不知道这一页该叫什么🧐" href="16347422574488.html">我也不知道这一页该叫什么🧐</a></li>
          
            <li><a title="烦😶‍🌫️" href="16325412705266.html">烦😶‍🌫️</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>dailyLife</span></li>
                        
                          <li><a title="holiday" href="16489947353638.html">holiday</a></li>
                        
                          <li><a title="practice" href="16481332591584.html">practice</a></li>
                        
                          <li><a title="JS每日一题" href="16471841635278.html">JS每日一题</a></li>
                        
                          <li><a title="🤯" href="16462320184228.html">🤯</a></li>
                        
                          <li><a title="notes" href="16460176233572.html">notes</a></li>
                        

                    
                      <li class="side-title"><span>algorithm</span></li>
                        
                          <li><a title="算法小记" href="16464916020294.html">算法小记</a></li>
                        

                    
                      <li class="side-title"><span>network</span></li>
                        
                          <li><a title="HTTPS" href="16445059759610.html">HTTPS</a></li>
                        
                          <li><a title="HTTP" href="16434685816689.html">HTTP</a></li>
                        
                          <li><a title="应用层" href="16429345213468.html">应用层</a></li>
                        
                          <li><a title="传输层" href="16427785444311.html">传输层</a></li>
                        
                          <li><a title="网络层" href="16406143899741.html">网络层</a></li>
                        
                          <li><a title="数据链路层" href="16393212106516.html">数据链路层</a></li>
                        
                          <li><a title="计算机网络" href="16376768137573.html">计算机网络</a></li>
                        

                    
                      <li class="side-title"><span>JS Pro</span></li>
                        
                          <li><a title="⭐️期约与异步函数" href="16402238078899.html">⭐️期约与异步函数</a></li>
                        
                          <li><a title="函数" href="16393591389076.html">函数</a></li>
                        
                          <li><a title="代理与反射" href="16393584526044.html">代理与反射</a></li>
                        
                          <li><a title="⭐️对象,类与面对对象编程" href="16382370352660.html">⭐️对象,类与面对对象编程</a></li>
                        
                          <li><a title="迭代器与生成器" href="16382368417536.html">迭代器与生成器</a></li>
                        
                          <li><a title="集合应用类型" href="16344851791468.html">集合应用类型</a></li>
                        
                          <li><a title="红宝书" href="16324468661377.html">红宝书</a></li>
                        

                    
                      <li class="side-title"><span>Vue</span></li>
                        
                          <li><a title="Principle" href="16417423637971.html">Principle</a></li>
                        
                          <li><a title="Webpack" href="16401645826486.html">Webpack</a></li>
                        
                          <li><a title="vue cli" href="16401638058072.html">vue cli</a></li>
                        
                          <li><a title="vue router" href="16400576847027.html">vue router</a></li>
                        

                    
                      <li class="side-title"><span>electron</span></li>
                        

                    
                      <li class="side-title"><span>Trick</span></li>
                        
                          <li><a title="笔试题" href="16512067476067.html">笔试题</a></li>
                        
                          <li><a title="MySQL" href="16417742815461.html">MySQL</a></li>
                        
                          <li><a title="eslint - vue" href="16378340644786.html">eslint - vue</a></li>
                        
                          <li><a title="我也不知道这一页该叫什么🧐" href="16347422574488.html">我也不知道这一页该叫什么🧐</a></li>
                        
                          <li><a title="烦😶‍🌫️" href="16325412705266.html">烦😶‍🌫️</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>函数</h1>

<p>函数实际上是<strong>对象</strong>，每个函数又都是<code>Function</code>类型的实例。</p>
<h2><a id="%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建函数</h2>
<ol>
<li>函数声明</li>
</ol>
<pre class="line-numbers"><code class="language-js">function sum (num1, num2) {
    return num1 + num2
}
</code></pre>
<ol start="2">
<li>函数表达式</li>
</ol>
<pre class="line-numbers"><code class="language-js">let sum = function(num1, num2) {
    return num1 + num2
};
</code></pre>
<ol start="3">
<li>箭头函数（arrow function）</li>
</ol>
<pre class="line-numbers"><code class="language-js">let sum = (num1, num2) =&gt; {
    return num1 + num2
}
</code></pre>
<ol start="4">
<li>构造函数(不推荐)</li>
</ol>
<pre class="line-numbers"><code class="language-js">let sum = new Function('num1', 'num2', 'return num1 + num2')
</code></pre>
<h2><a id="%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>箭头函数</h2>
<p>ES6新增语法糖</p>
<ul>
<li>箭头函数不能使用arguments，super和new.target，也不能用作构造函数。</li>
<li>此外，箭头函数也没有prototype属性（指向Function构造函数）</li>
</ul>
<h2><a id="%E5%87%BD%E6%95%B0%E5%90%8D%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数名 --- 指向函数的指针</h2>
<p>ES6的所有函数对象都会暴露一个只读的<code>name</code>属性。多数情况下，这个属性中保存的就是一个函数表示符，或者说是函数创建时的变量名字符串。</p>
<pre class="line-numbers"><code class="language-js">function foo() {}
let bar = function() {}
let baz = () =&gt; {}

console.log(foo.name) // foo
console.log(bar.name) // bar
console.log(baz.name) // baz
console.log((() =&gt; {}).name) // (空字符串)
console.log((new Function()).name) // anonymous(匿名)
</code></pre>
<p>如果函数是一个获取函数，设置函数，或者使用bind()实例化，那么表示符前面会加上一个前缀：</p>
<pre class="line-numbers"><code class="language-js">function foo() {}
console.log(foo.bind(null).name) // bound foo
</code></pre>
<h2><a id="%E7%90%86%E8%A7%A3%E5%8F%82%E6%95%B0%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>理解参数 --- 数组</h2>
<p>函数的参数在内部表现为一个<strong>数组</strong>。在使用function关键字定义（非箭头）函数时，可以在函数内部访问<code>arguments</code>对象，从中取得传进来的每个参数值。</p>
<p>argument对象是一个伪数组对象（不是Array实例）。具有<code>arguments.length</code>属性</p>
<h3><a id="%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>箭头函数中的参数</h3>
<p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用arguments关键字访问，而只能通过定义的<strong>命名参数</strong>访问。</p>
<pre class="line-numbers"><code class="language-js">let bar = () =&gt; {
    console.log(arguments[0])
}
bar(5) // ReferenceError
</code></pre>
<p>tips:</p>
<pre class="line-numbers"><code class="language-js">function foo() {
    let bar = () =&gt; {
        console.log(arguments[0])
    }
    bar()
}

foo(5) // 5
</code></pre>
<h3><a id="%E6%B2%A1%E6%9C%89%E9%87%8D%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>没有重载</h3>
<p>ECMAScript函数没有签名，因为参数是由包含零个或多个值的数组表示的。没有函数签名，自然也就没有重载。<br />
如果定义了两个同名函数，后定义的会覆盖先定义的。</p>
<h3><a id="%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>默认参数值</h3>
<p>ES6之前：默认为<code>undefined</code><br />
ES6:支持显示定义默认参数。箭头函数也支持</p>
<ul>
<li>在<strong>使用默认参数时</strong>，arguments对象的值不反映参数的默认值，只反映传给函数的参数。设定初始值后便同ES5严格模式，修改命名参数也不会影响arguments对象。</li>
</ul>
<pre class="line-numbers"><code class="language-js">function makeKing(name = 'Henry') {
    name = 'Louis'
    return `King ${arguments[0]} Queen ${name}`
}
console.log(makeKing()) // 'King undefined Queen Louis'
console.log(makeKing('DC')) // 'King DC Queen Louis'
</code></pre>
<p>ES5普通模式:</p>
<pre class="line-numbers"><code class="language-js">function makeKing(name) {
    name = 'Louis'
    return `King ${arguments[0]}`
}

console.log(makeKing()) // 'King undefined'
console.log(makeKing('DC')) // 'King Louis'
</code></pre>
<ul>
<li>默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值。计算默认值的函数只有在调用函数但未传相应参数时才会被调用。</li>
</ul>
<h4><a id="%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>默认参数作用域与暂时性死区</h4>
<p>给多个参数定义默认值实际上跟使用let关键字<strong>顺序声明</strong>变量一样。</p>
<pre class="line-numbers"><code class="language-js">function makeKing(name = 'Henry', numerals = name) {
    return `King ${name} ${numerals}`
}

console.log(makeKing()) // King Henry Henry
</code></pre>
<ul>
<li>参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。</li>
<li>参数也存在于自己的作用域中，它们不能引用函数体的作用域。</li>
</ul>
<h3><a id="%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E4%B8%8E%E6%94%B6%E9%9B%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数扩展与收集</h3>
<p>ES6新增了<code>...</code>扩展运算符</p>
<h4><a id="%E6%89%A9%E5%B1%95%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展参数</h4>
<pre class="line-numbers"><code class="language-js">let values = [1, 2, 3, 4]

function countArguments() {
    console.log(arguments.length)
}

countArguments(...values, ...[5, 6, 7]) // 7
countArguments(1, 2, 3, 4, 5, 6, 7) // 7
</code></pre>
<h4><a id="%E6%94%B6%E9%9B%86%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>收集参数</h4>
<p>因为收集参数的结果可变，所以只能把它作为最后一个参数：</p>
<pre class="line-numbers"><code class="language-js">function ignoreFirst(firstValue, ...values) {
    console.log(values)
}

ignoreFirst() // []
ignoreFirst(1) // []
ignoreFirst(1, 2) // [1]
ignoreFirst(1, 2, 3) // [1, 2]
</code></pre>
<h2><a id="%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数声明与函数表达式</h2>
<p>函数声明提升：<strong>函数声明</strong>会在任何代码执行之前先被读取并添加到执行上下文中。而函数表达式只会进行变量提升，函数不会提升</p>
<pre class="line-numbers"><code class="language-js">// 没问题但不推荐，严格模式会报错
console.log(sum(10, 10)) // 20
function sum(num1, num2) {
    return num1 + num2
}
</code></pre>
<pre class="line-numbers"><code class="language-js">console.log(sum(10, 10)) // ReferenceError
let sum = function(num1, num2) {
    return num1 + num2
}
</code></pre>
<h2><a id="%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数作为值</h2>
<p><strong>函数名也是变量</strong></p>
<h3><a id="1%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.函数作为参数</h3>
<pre class="line-numbers"><code class="language-js">function callSomeFunction(someFunction, someArgument) {
    return someFunction(someArgument)
}

function add10(num) {
    return num + 10
}
let result = callSomeFunction(add10, 10)
console.log(result) // 20
</code></pre>
<h3><a id="2%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.函数作为返回值</h3>
<pre class="line-numbers"><code class="language-js">function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        let value1 = object1[propertyName]
        let value2 = object2[propertyName]
        
        if (value1 &lt; value2) {
            return -1
        } else if (value1 &gt; value2) {
            return 1
        } else {
            return 0
        }
    }
}

let data = [
    {name: &quot;Zachary&quot;, age: 28},
    {name: &quot;Nicholas&quot;, age: 29}
]
data.sort(createComparisonFunction(&quot;name&quot;))
console.log(data[0].name) // Nicholas
</code></pre>
<h2><a id="%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数内部</h2>
<p>ES5:<code>arguments</code>对象和<code>this</code>对象<br />
ES6新增:<code>new.target</code>属性</p>
<h3><a id="arguments" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>arguments</h3>
<ol>
<li>包含调用函数时传入的所有参数，同上</li>
<li><code>callee</code>属性，是一个指向arguments对象所在函数的指针 <code>不推荐使用</code></li>
</ol>
<pre class="line-numbers"><code class="language-js">// 解耦递归
function factorial(num) {
    if (num &lt;= 1) {
        return 1
    } else {
        return num * arguments.callee(num - 1)
        // equal: return num * factorial(num - 1)
    }
}
</code></pre>
<h3><a id="this" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this</h3>
<h4><a id="%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E4%B8%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标准函数中</h4>
<blockquote>
<p>标准函数中，this引用的是把函数当成方法<strong>调用</strong>的上下文对象</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">window.color = 'red'
let o = {
	color: 'blur'
}

function sayColor() {
	console.log(this.color)
}

sayColor() // 'red'

o.sayColor = sayColor
o.sayColor() // 'blue'
</code></pre>
<h4><a id="%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>箭头函数中</h4>
<blockquote>
<p>箭头函数中，this引用的是<strong>定义</strong>箭头函数的上下文</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">window.color = 'red'
let o = {
	color: 'blur'
}

let sayColor = () =&gt; {
	console.log(this.color)
}

sayColor() // 'red'

o.sayColor = sayColor
o.sayColor() // 'red'
</code></pre>
<h4><a id="tips" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>tips</h4>
<blockquote>
<p>事件回调或定时回调时，其上下文为<code>window</code>对象 --- 箭头函数解决this指向</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">function King() {
	this.royaltyName = 'Henry'
	// this引用King实例
	window.setTimeout(() =&gt; { console.log(this.royaltyName) }, 1000)
}

function Queen() {
	this.royaltyName = 'Elizabeth'
	// this引用window实例
	window.setTimeout(function() { console.log(this.royaltyName) }, 1000)
}

new King() // Henry (this指向King实例)
new Queen() // undefined (this指向window对象)
</code></pre>
<h3><a id="caller" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>caller</h3>
<blockquote>
<p>该属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为<code>null</code></p>
</blockquote>
<pre class="line-numbers"><code class="language-js">function outer() {
    inner()
}

function inner() {
    console.log(inner.caller)
}

outer() // f: outer() { ... }
</code></pre>
<h3><a id="new-target" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>new.target</h3>
<p><code>ES6新增</code></p>
<blockquote>
<p>该属性用于检测函数是否使用<code>new</code>关键字调用</p>
</blockquote>
<p>正常调用：new.target = underfined<br />
new关键字调用：被调用的构造函数</p>
<h2><a id="%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数属性与方法</h2>
<p>函数是<strong>对象</strong>，所以也会有属性和方法。每个函数都有两个属性：<code>length</code>和<code>prototype</code></p>
<h3><a id="length" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>length</h3>
<blockquote>
<p>length属性保存函数定义的命名参数的个数</p>
</blockquote>
<h3><a id="prototype" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>prototype</h3>
<blockquote>
<p>prototype是保存引用类型所有实例方法的地方，进而由所有实例共享。</p>
</blockquote>
<h4><a id="callapplybind" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>call/apply/bind</h4>
<blockquote>
<p>call/apply：都会以指定的this值<strong>调用函数</strong>。后者传数组。</p>
</blockquote>
<blockquote>
<p>bind：创建一个新的函数实例，其this值会被<strong>绑定</strong>到传给bind()的对象。【不会调用函数】</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">window.color = 'red'
let o = { color: 'blue' }
function sayColor() {
    console.log(this.color)
}
let objectSayColor = sayColor.bind(o)
sayColor() // red
objectSayColor() // blue
</code></pre>
<h2><a id="%E9%80%92%E5%BD%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>递归</h2>
<blockquote>
<p>递归函数通常的形式是一个函数通过名称调用自己</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">// 正常
function factorial(num) {
    if (num &lt;= 1) {
        return 1
    } else {
        return factorial(num - 1)
    }
}
</code></pre>
<pre class="line-numbers"><code class="language-js">let anotherFactorial = factorial
factorial = null
console.log(anotherFactorial(4)) // Error: ...
</code></pre>
<ul>
<li>如果吧这个函数<code>factorial</code>赋值给别的变量，就会出现问题.</li>
</ul>
<hr />
<pre class="line-numbers"><code class="language-js">// 优化1:通过arguments.callee
function factorial(num) {
    if (num &lt;= 1) {
        return 1
    } else {
        return num * arguments.callee(num - 1)
    }
}
</code></pre>
<ul>
<li>Warn：<strong>严格模式</strong>下运行的代码是不能访问arguments.callee的，因为访问会出错。</li>
</ul>
<pre class="line-numbers"><code class="language-js">// 优化2:使用命名函数表达式(named function expression)达到目的
const factorial = (function f(num) {
    if (num &lt;= 1) {
        return 1
    } else {
        return num * f(num - 1)
    }
})
</code></pre>
<ul>
<li>上方法在严格模式下也可使用</li>
</ul>
<h2><a id="%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>尾调用优化 TODO</h2>
<p><code>ES6新增了一项内存管理优化机制，让JS引擎在满足条件时可以重用栈帧。--- 非常适合‘尾调用’</code></p>
<blockquote>
<p>尾调用：外部函数的返回值是一个内部函数的返回值。</p>
</blockquote>
<p>严格模式下才可进行尾调用优化。</p>
<p>有点nb</p>
<h2><a id="%F0%9F%8C%9F%E9%97%AD%E5%8C%85closure-todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>🌟闭包 closure TODO</h2>
<blockquote>
<p>闭包：引用了另一个函数作用域中变量 的 <strong>函数</strong>，通常是在嵌套函数中实现的。</p>
</blockquote>
<h3><a id="this%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>this对象</h3>
<h3><a id="%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存泄漏</h3>
<h2><a id="%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>立即调用的函数表达式</h2>
<p>IIFE【Immediately Invoked Function Expression】</p>
<blockquote>
<p>立即调用的匿名函数，又被称为立即调用的函数表达式。它类似函数声明，但由于被包含在括号中，所以会被解释为<strong>函数表达式</strong>。 --- 不会函数提升</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">;(function() {
    // 块级作用域
})()
</code></pre>
<h3><a id="%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>作用</h3>
<blockquote>
<p>ES5尚未支持块级作用域，便可使用IIFE<strong>模拟块级作用域</strong></p>
</blockquote>
<ul>
<li>var定义的变量没有块级作用域：</li>
</ul>
<pre class="line-numbers"><code class="language-js">let divs = document.querySelectorAll('div')

// 达不到目的
for (var i = 0; i &lt; divs.length; i++) {
    divs[i].addEventListener('click', function() {
        console.log(i) // divs.length
    })
}

console.log(i) // divs.length
</code></pre>
<p><code>通过闭包改进</code>：</p>
<pre class="line-numbers"><code class="language-js">for (var i = 0; i &lt; divs.length; i++) {
    divs[i].addEventListener('click', (function(frozenCounter) {
        return function() { console.log(frozenCounter) }
    })(i))
}
</code></pre>
<p><code>使用ES6 let定义块级作用域变量改进</code>：</p>
<pre class="line-numbers"><code class="language-js">for (let i = 0; i &lt; divs.length; i++) {
    divs[i].addEventListener('click', function() {
        console.log(i)
    })
}

console.log(i) // ReferenceError: i is not defined
</code></pre>
<h2><a id="%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>私有变量</h2>
<blockquote>
<p>任何定义在<code>函数或块</code>中的变量（<u>函数参数、局部变量，以及函数内部定义的其他函数</u>），都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量。</p>
</blockquote>
<ul>
<li>特权方法（privileged method）：指能够访问函数私有变量（及私有函数）的<strong>公有方法</strong>。</li>
</ul>
<h3><a id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造函数模式</h3>
<blockquote>
<p>定义在构造函数中的特权方法其实是一个<strong>闭包</strong>，它具有访问构造函数中定义的所有变量和函数的能力。</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">function MyObject() {
    // 私有变量和私有函数
    let privateVariable = 10
    function privateFunction() {
        return false
    }
    
    // 特权方法
    this.publicMethod = function() {
        privateVariable++
        return privateFunction()
    }
    this.getMethod = function() {
        return privateVariable
    }
}

let test1 = new MyObject()
let test2 = new MyObject()
test1.publicMethod()
console.log(test1.getMethod()) // 11
console.log(test2.getMethod()) // 10
</code></pre>
<p>缺点：每个实例都会重新创建一遍新的特权方法。</p>
<h3><a id="%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用静态私有变量实现</h3>
<blockquote>
<p>通过使用私有作用域定义私有变量和函数来实现</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">let MyObject
(function() {
    // 私有变量和私有函数
    let privateVariable = 10
    function privateFunction() {
        return false
    }
    
    //  构造函数
    MyObject = function() {}
    
    // 公有和特权方法
    MyObject.prototype.publicMethod = function() {
        privateVariable++
        return privateFunction()
    }
    MyObject.prototype.getMethod = function() {
        return privateVariable
    }
})()

let test1 = new MyObject()
let test2 = new MyObject()
test1.publicMethod()
console.log(test1.getMethod()) // 11
console.log(test2.getMethod()) // 11
</code></pre>
<p>特点：可以利用原型更好的重用代码(特权方法)，但每个实例没有了自己的私有变量，私有变量是共享的。</p>
<h3><a id="%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模块模式</h3>
<blockquote>
<p>在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法。</p>
</blockquote>
<p>单例对象【singleton】：只有一个实例的对象。一般通过对象字面量来创建。</p>
<pre class="line-numbers"><code class="language-js">let singleton = {
    name: value,
    method() {
        // code...
    }
}
</code></pre>
<p>模块模式样板：使用匿名函数返回一个对象</p>
<pre class="line-numbers"><code class="language-js">let singleton = function() {
    // 私有变量和私有函数
    let privateVariable = 10
    function privateFunction() {
        return false
    }
    
    // 特权/公有方法和属性
    return {
        publicProperty: true,
        publicMethod() {
            privateVariable++
            return privateFunction()
        }
    }
}
</code></pre>
<h3><a id="%E6%A8%A1%E5%9D%97%E5%A2%9E%E5%BC%BA%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模块增强模式</h3>
<blockquote>
<p>在返回对象之前先对其进行增强。这适合单例对象需要是某个特定类型的实例，但又必须给它添加额外属性或方法的场景。</p>
</blockquote>
<pre class="line-numbers"><code class="language-js">// 需返回特定类型CustomType的实例
let singleton = function() {
    // 私有变量和私有函数
    let privateVariable = 10
    function privateFunction() {
        return false
    }
    
    // 创建对象
    let object = new CustomType()
    
    // 添加特权/公有方法和属性
    object.publicProperty = true
    object.publicMethod = function() {
        privateVariable++
        return privateFunction()
    }
    
    return object
}
</code></pre>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="16400576847027.html"  title="Previous Post: vue router">&laquo; vue router</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="16393584526044.html" 
	        title="Next Post: 代理与反射">代理与反射 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '16393591389076.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0.4em 0;padding: 0;}
  figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }


</style>
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>


  </body>
</html>
